package com.into.websoso.ui.onboarding

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.SavedStateHandle
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.into.websoso.data.repository.AuthRepository
import com.into.websoso.domain.model.NicknameValidationResult
import com.into.websoso.domain.usecase.CheckNicknameValidityUseCase
import com.into.websoso.domain.usecase.ValidateNicknameUseCase
import com.into.websoso.ui.onboarding.OnboardingActivity.Companion.ACCESS_TOKEN_KEY
import com.into.websoso.ui.onboarding.OnboardingActivity.Companion.REFRESH_TOKEN_KEY
import com.into.websoso.ui.onboarding.first.model.NicknameInputType
import com.into.websoso.ui.onboarding.first.model.OnboardingFirstUiState
import com.into.websoso.ui.onboarding.model.OnboardingPage
import com.into.websoso.ui.onboarding.model.UserModel
import com.into.websoso.ui.onboarding.second.model.OnboardingSecondUiState
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class OnboardingViewModel @Inject constructor(
    private val authRepository: AuthRepository,
    private val validateNicknameUseCase: ValidateNicknameUseCase,
    private val checkNicknameValidityUseCase: CheckNicknameValidityUseCase,
    private val savedStateHandle: SavedStateHandle
) : ViewModel() {
    private val _currentPage = MutableLiveData(OnboardingPage.FIRST)
    val currentPage: LiveData<OnboardingPage> get() = _currentPage

    private val _progressBarPercent = MutableLiveData(OnboardingPage.FIRST.progressPercent)
    val progressBarPercent: LiveData<Int> get() = _progressBarPercent

    private val _isBackButtonVisible = MutableLiveData(OnboardingPage.FIRST.isBackButtonVisible)
    val isBackButtonVisible: LiveData<Boolean> get() = _isBackButtonVisible

    private val _isSkipTextVisible = MutableLiveData(OnboardingPage.FIRST.isSkipTextVisible)
    val isSkipTextVisible: LiveData<Boolean> get() = _isSkipTextVisible

    private val _onboardingFirstUiState: MutableLiveData<OnboardingFirstUiState> =
        MutableLiveData(OnboardingFirstUiState())
    val onboardingFirstUiState: LiveData<OnboardingFirstUiState> get() = _onboardingFirstUiState

    private val _onboardingSecondUiState: MutableLiveData<OnboardingSecondUiState> =
        MutableLiveData(OnboardingSecondUiState())
    val onboardingSecondUiState: LiveData<OnboardingSecondUiState> get() = _onboardingSecondUiState

    val currentNicknameInput: MutableLiveData<String> = MutableLiveData("")

    private val _userProfile: MutableLiveData<UserModel> = MutableLiveData(UserModel())
    val userProfile: LiveData<UserModel> get() = _userProfile

    private val _selectedGenres = MutableLiveData<Set<String>>(setOf())
    val selectedGenres: LiveData<Set<String>> get() = _selectedGenres

    private val _isUserProfileSubmit = MutableLiveData<Boolean>(false)
    val isUserProfileSubmit: LiveData<Boolean> get() = _isUserProfileSubmit

    var accessToken: String
        get() = savedStateHandle[ACCESS_TOKEN_KEY] ?: ""
        private set(value) { savedStateHandle[ACCESS_TOKEN_KEY] = value }

    var refreshToken: String
        get() = savedStateHandle[REFRESH_TOKEN_KEY] ?: ""
        private set(value) { savedStateHandle[REFRESH_TOKEN_KEY] = value }

    fun validateNickname() {
        val currentInput: String = currentNicknameInput.value.orEmpty()
        if (currentInput.isEmpty()) {
            updateOnBoardingFirstUiState(NicknameInputType.INITIAL, "")
            return
        }
        val (isSuccess, message) = validateNicknameUseCase(currentInput)
        when (isSuccess) {
            true -> updateOnBoardingFirstUiState(NicknameInputType.TYPING, message)
            false -> updateOnBoardingFirstUiState(NicknameInputType.ERROR, message)
        }
    }

    fun dispatchNicknameValidity() {
        val nickname = currentNicknameInput.value ?: ""
        viewModelScope.launch {
            runCatching {
                checkNicknameValidityUseCase(nickname)
            }.onSuccess { result ->
                when (result) {
                    NicknameValidationResult.VALID_NICKNAME_SPELLING -> dispatchNicknameDuplication(
                        nickname
                    )

                    else -> updateOnBoardingFirstUiState(
                        NicknameInputType.ERROR,
                        result.profileEditMessage
                    )
                }
            }.onFailure {
                updateOnBoardingFirstUiState(
                    NicknameInputType.ERROR,
                    NicknameValidationResult.UNKNOWN_ERROR.profileEditMessage
                )
            }
        }
    }

    private fun dispatchNicknameDuplication(nickname: String) {
        viewModelScope.launch {
            runCatching {
                authRepository.fetchNicknameValidity(accessToken, nickname)
            }.onSuccess { isNicknameValid ->
                when (isNicknameValid) {
                    true -> {
                        updateOnBoardingFirstUiState(
                            NicknameInputType.COMPLETE,
                            NicknameValidationResult.VALID_NICKNAME.profileEditMessage
                        )
                    }

                    false -> {
                        updateOnBoardingFirstUiState(
                            NicknameInputType.ERROR,
                            NicknameValidationResult.INVALID_NICKNAME_DUPLICATION.profileEditMessage
                        )
                    }
                }
            }.onFailure {
                updateOnBoardingFirstUiState(
                    NicknameInputType.ERROR,
                    NicknameValidationResult.NETWORK_ERROR.profileEditMessage
                )
            }
        }
    }

    private fun updateOnBoardingFirstUiState(type: NicknameInputType, message: String) {
        _onboardingFirstUiState.value = onboardingFirstUiState.value?.copy(
            nicknameInputType = type,
            nicknameValidationMessage = message,
            isDuplicationCheckButtonEnable = type == NicknameInputType.TYPING,
            isNextButtonEnable = type == NicknameInputType.COMPLETE
        )
    }

    fun updateNicknameInputType(nicknameInputType: NicknameInputType) {
        updateOnBoardingFirstUiState(nicknameInputType, "")
    }

    fun clearInputNickname() {
        if (onboardingFirstUiState.value?.nicknameInputType != NicknameInputType.COMPLETE) {
            currentNicknameInput.value = ""
        }
    }

    fun goToNextPage() {
        _currentPage.value?.let { currentPage ->
            val nextPage = currentPage.nextPage()
            if (nextPage != currentPage) {
                _currentPage.value = nextPage
                updateUIByPage(nextPage)
            }
        }
    }

    fun goToPreviousPage() {
        _currentPage.value?.let { currentPage ->
            val previousPage = currentPage.previousPage()
            if (previousPage != currentPage) {
                _currentPage.value = previousPage
                updateUIByPage(previousPage)
            }
        }
    }

    private fun updateUIByPage(page: OnboardingPage) {
        with(page) {
            _progressBarPercent.value = progressPercent
            _isBackButtonVisible.value = isBackButtonVisible
            _isSkipTextVisible.value = isSkipTextVisible
        }
    }

    fun updateUserBirthYear(birthYear: Int) {
        _userProfile.value = userProfile.value?.copy(birthYear = birthYear)
        updateSecondNextButtonUiState()
    }

    fun updateUserGenderUiState(isManSelected: Boolean) {
        _onboardingSecondUiState.value = onboardingSecondUiState.value?.copy(
            isManSelected = isManSelected,
            isWomanSelected = !isManSelected,
        )
        updateUserGender(isManSelected)
    }

    private fun updateUserGender(isManSelected: Boolean) {
        _userProfile.value =
            userProfile.value?.copy(gender = if (isManSelected) GENDER_MALE else GENDER_FEMALE)
        updateSecondNextButtonUiState()
    }

    private fun updateSecondNextButtonUiState() {
        _onboardingSecondUiState.value = onboardingSecondUiState.value?.copy(
            isNextButtonEnable = !userProfile.value?.gender.isNullOrEmpty() && userProfile.value?.birthYear != UNSELECTED_BIRTH_YEAR
        )
    }

    fun updateGenreSelection(genreTag: String) {
        val currentSelected = _selectedGenres.value?.toMutableSet() ?: mutableSetOf()
        when (currentSelected.contains(genreTag)) {
            true -> currentSelected.remove(genreTag)
            false -> currentSelected.add(genreTag)
        }
        _selectedGenres.value = currentSelected

        _userProfile.value = _userProfile.value?.copy(
            genrePreferences = currentSelected.toList()
        )
    }

    fun isGenreSelected(genreTag: String): Boolean {
        return _selectedGenres.value?.contains(genreTag) ?: false
    }

    fun submitUserProfile() {
        viewModelScope.launch {
            runCatching {
                _userProfile.value = userProfile.value?.copy(
                    nickname = currentNicknameInput.value.orEmpty(),
                )
                userProfile.value?.let { profile ->
                    authRepository.signUp(
                        authorization = accessToken,
                        nickname = profile.nickname,
                        gender = profile.gender,
                        birth = profile.birthYear,
                        genrePreferences = profile.genrePreferences,
                    )
                }
            }.onSuccess {
                authRepository.updateAccessToken(accessToken)
                authRepository.updateRefreshToken(refreshToken)
                authRepository.updateIsAutoLogin(true)
                _isUserProfileSubmit.value = true
            }.onFailure { exception ->
                exception.printStackTrace()
            }
        }
    }

    fun clearGenreSelection() {
        _selectedGenres.value = setOf()
    }

    companion object {
        private const val GENDER_MALE = "M"
        private const val GENDER_FEMALE = "F"
        private const val UNSELECTED_BIRTH_YEAR = 0
    }
}
